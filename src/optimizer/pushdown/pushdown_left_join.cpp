#include "optimizer/filter_pushdown.hpp"

#include "planner/operator/logical_comparison_join.hpp"

#include "parser/expression/constant_expression.hpp"

#include "execution/expression_executor.hpp"

using namespace duckdb;
using namespace std;

using Filter = FilterPushdown::Filter;

static unique_ptr<Expression> ReplaceColRefWithNull(unique_ptr<Expression> expr) {
	if (expr->type == ExpressionType::BOUND_COLUMN_REF) {
		return make_unique<ConstantExpression>(Value(expr->return_type));
	}
	expr->EnumerateChildren([&](unique_ptr<Expression> child) -> unique_ptr<Expression> {
		return ReplaceColRefWithNull(move(child));
	});
	return expr;
}

static bool FilterRemovesNull(Expression *expr) {
	// make a copy of the expression
	auto copy = expr->Copy();
	// replace all BoundColumnRef expressions with NULL constants in the copied expression
	copy = ReplaceColRefWithNull(move(copy));
	if (!copy->IsScalar()) {
		return false;
	}
	// flatten the scalar
	auto val = ExpressionExecutor::EvaluateScalar(*copy).CastAs(TypeId::BOOLEAN);
	// if the result of the expression with all expressions replaced with NULL is "NULL" or "false"
	// then any extra entries generated by the LEFT OUTER JOIN will be filtered out!
	// hence the LEFT OUTER JOIN is equivalent to an inner join
	return val.is_null || !val.value_.boolean;
}

unique_ptr<LogicalOperator> FilterPushdown::PushdownLeftJoin(unique_ptr<LogicalOperator> op,
                                                             unordered_set<size_t> &left_bindings,
                                                             unordered_set<size_t> &right_bindings) {
 	auto &join = (LogicalJoin &)*op;
	assert(join.type == JoinType::LEFT);
	assert(op->type != LogicalOperatorType::DELIM_JOIN);
	FilterPushdown left_pushdown, right_pushdown;
	// now check the set of filters
	for (size_t i = 0; i < filters.size(); i++) {
		auto side = LogicalComparisonJoin::GetJoinSide(filters[i]->bindings, left_bindings, right_bindings);
		if (side == JoinSide::LEFT) {
			// bindings match left side: push into left
			left_pushdown.filters.push_back(move(filters[i]));
			// erase the filter from the list of filters
			filters.erase(filters.begin() + i);
			i--;
		} else if (side == JoinSide::RIGHT) {
			// bindings match right side: we cannot directly push it into the right
			// however, if the filter removes rows with null values we can turn the left outer join
			// in an inner join, and then push down as we would push down an inner join
			if (FilterRemovesNull(filters[i]->filter.get())) {
				// the filter removes NULL values, turn it into an inner join
				join.type = JoinType::INNER;
				// now we can do more pushdown
				// move all filters we added to the left_pushdown back into the filter list
				for(auto &left_filter : left_pushdown.filters) {
					filters.push_back(move(left_filter));
				}
				// now push down the inner join
				return PushdownInnerJoin(move(op), left_bindings, right_bindings);
			}
		}
	}
	op->children[0] = left_pushdown.Rewrite(move(op->children[0]));
	op->children[1] = right_pushdown.Rewrite(move(op->children[1]));
	return FinishPushdown(move(op));
}